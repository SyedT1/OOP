2021-11-22 -- Scratchpad of CSE213 (Sec-2)
==========================================

File Handling in Java (File I/O):
=================================

	- Text file: 
		- Stores character, so that any text editor can open & read the content

	- Binary file:
		- Stores raw data (bytes)

Difference between text & binary file:
--------------------------------------
 - storage device stores	: binary equivalent (irrespective of fle type)
	- SSD/FlashDrive/RAM	: presence/absence of electric charges
	- Magnetic drive	: megnetized/demagnetized cell
	- Optical drive		: high/low intensity laser pits

 - Text file:
	- Every bytes of a text file is considered as the ascii code of a character
	- When we open a text file using a text editor (notepad, subline, word, IDE...)
		it shows corresponding character for the bytes stored in that file
	- Therefore, we use text file to store textual data

 - Binary file:
	- Store raw data:
		- image file (collection of pixel bytes)
		- Audio file	
		- video file
		- writing/reading class instances to/from file
		- database

Q: What type of file you will use for your project
A: 
	- Mostly we will use binary files
	- A few text files


Why we will use binary file for our project:
===========================================

Suppose we have an int x = 123
binary of 123 (4 bytes) is:  00000000 00000000 00000000 01111011
these 4 bytes need to be converted to bytes (ascii code) of character '1', '2' & '3'
	
binary of "123": 		00110001 00110010 00110011

 - While writing: Integer.toString(..);	//additional task
	Conversion: 00000000 00000000 00000000 01111011 --> 00110001 00110010 00110011

 - While reading : Integer.parseInt(..);	//additional task
	Conversion: 00110001 00110010 00110011 --> 00000000 00000000 00000000 01111011

 - Also, keeping application data in text file will allow anyone to view the content using
	any text editor. But the content of a binary file can't be retrieved unless the 
	other application knows the metadata.

 - We can also have some text file in our project such as "readme.txt", "faq.txt", "about.txt"


Streams that we can use to perform console IO in java:
======================================================
Classes:
 - C++:
	Reading: istream
	Writing: ostream
 - Java:
	Reading: InputStream or Scanner for convenience (System.in will be source of Scanner)
	Writing: PrintStream


Streams that we can use to perform file IO in java:
===================================================

C++: Stream classes:
--------------------
	Reading from file	: ifstream
	Writing to file		: ofstream
	Read/write together	: fstream
Java:
-----
 - Byte stream					[Both for text & binary file]
	- read/write raw bytes from/to file
	Classes:
		Reading: FileInputStream
		Writing: FileOutputStream

 - Character stream				[For text file, recommended]
	- read/write characters from/to file
	Classes:
		Reading: FileReader or Scanner for convenience (File will be source of Scanner)
		Writing: FileWriter

 - Data stream					[For binary file]
	- read/write different data types as it is (their actual bytes) from/to file
	Classes:
		Reading: DataInputStream
		Writing: DataOutputStream

	As an intermediate layer to increase read/write efficiency, we can use Buffer in between
	Data & Byte streams
		Classes: BufferedInputStream & BufferedOutputStream

 - Object stream					[For binary file]
	- read/write deserialized/serialized class instances from/to file
	Classes:
		Reading: ObjectInputStream
		Writing: ObjectOutputStream

Text File:
	- We can use Byte stream (if it is 1-byte ASCII character) as well as Character stream

Binary file:
	- Data & Object stream will be used for your project. However, these Data & Object stream
		will internally use Byte stream
	- To generate pdf/jpg --> Byte stream
	- int/float/String & mix of them --> Data stream
	- Only class instances --> Object stream

NOTE: To perform file IO, we need to deploy Exception Handling mechanism

===============================================================================================

Exception Handling:
===================
	int main(){
		int a,b,c;	cin>>a>>b;
		c = a/b;		//critical statement,	//Exception: division by zero
		cout<<a<<b<<c;
		return 0;
	}

	//we can avoid this / by 0 situation by optimizing our source code, 
	//Without deploying Exception hndling mechanism.
	int main(){
		int a,b,c;	cin>>a;
		do{
			cin>>b;
		}while(b==0);
		c = a/b;	//critical statement, avoided exception by optimizing source code
		cout<<a<<b<<c;
		return 0;
	}

 - So far, the programs that we have written had some critical statements, and by analyzing
   the source code, compiler knows potential exception from those critical statements
   can be avoided by optimizing the source code	[UNCHECKED Exception].

 - Therefore, compiler never forced us to deploy EH-mechanism for potential UNCHECKED exceptions. 

 - BUT, there can be some critical statements which might fail during runtime due to some
   external factors, which is beyond the control of the programmer, and therefore it
   may not be possible to avoid that situation by optimizing our source code. [CHECKED Exception]

 - For these critical statements, compiler forces us to deploy EH-mechanism:
	- using try-catch-finally block

 - File I/O related exceptions are CHECKED exception, 

 - File handling is one such case, where exception handling is enforced.


What is Exception????
---------------------
	In C++: It can be any data type
	In Java: It is an instance of ONE-OF-THE Exception class family (inheritance)

int cppArr[5] = {1,2,3,4,5};
	cout<<cppArr[2];	//3
	cout<<cppArr[5];	//garbage

int[] javaArr = {11,22,33,44,55};
	sout(cppArr[2]);	//33
	sout(cppArr[5]);	//JVM wll throw an ArrayIndexOutOfBoundsException instance, 
				//and if the thrown exception is not handled, your program will crash


public class SomeClass{
	public void someMethod(){
		Scanner s = new Scanner(System.in);
		a = s.nextInt(); b = s.nextInt();
		
		c = a/b;	
		// if b is zero, and code is not optimized, so, / by 0 will occur
		//at this point an ArithmeticException instance will be thrown implicitly by JVM
		//and since there is no catch block, the program will crash immediately

		sout(...);	//this line and lines below will never be executed..
		......		
	}
}



public class SomeClass{
	public void someMethod(){
	    try{
		Scanner s = new Scanner(System.in);
		a = s.nextInt(); b = s.nextInt();
		
		c = a/b;
		// if b is zero, and code is not optimized, so, / by 0 will occur
		//at this point an ArithmeticException instance will be thrown implicitly by JVM
		//and since there is no catch block, the program will crash immediately

		sout(...);	//this and lines below will never be executed..
		......	
 	    }
	    catch(ArithmeticException e){ 
		//exception handling code	
		//e.someMethodOfArithmeticException();
		//e.someGetter(); //to get exception related info to show to the user
		//your own handling code...
	    }
	    //after handling, control will continue from here
	}
}

- You can also have your own exception:
	public class MyException extends AnyOfTheExceptionClassFromExceptionHierarchy {

	}

Five keywords that we need to understand for exception handling:
----------------------------------------------------------------
try:
----
	- represents the block where the critical statements are kept
		(we try to execute critical ststemets here)
	- can have nested try blocks
	- while trying to execute the code inside try block, if an exceptional context arise
		a suitable Exception type instance is thrown by the JVM. Therefore, 
		there must be atleast one (or more) corresponding handling block (catch) 
		associated with the try block.
	- the thrown instance contains runtime contextual data of the exceptional situation
		as fields, which can be used in catck block for amicable solution
	- Once an exception is thrown at a critical ststement, control will leave the try block
		and as a result, rest of the ststements of the try block will NEVER be ececuted

catch:
------
	- exception handling block (handling code are kept here)
	- When multiple catch blocks are associated with a try block, we keep the MOST
		MOST specific catch block (subclass) at the top, and  
		MOST generic (superclass) catch block at the bottom.

	Ex: wrong ordering of catch blocks
	try{
		....
	}
	catch(SQLException e){//SQL exception specific handling code...}
	catch(RuntimeException e){//handling code...}
	catch(ArithmeticException e){//handling code...}

	Ex: correct ordering of catch blocks
	try{
		//.... 50 lines of code, has potential of 10 different exceptio
		//but you have only 3 catch blocks.
		//if the thrown exception is caught by one of the following 3 catch blocks
		//the throws exception is handled and program will continue.
		//But, if an exception is throws and is not matched with any of the following
		//catch blocks, your program will still crash.

		//to solve the problem, we can provide THE MOST generic catch block
		//which will catch any missed exception
	}
	catch(SQLException e){//SQL exception specific handling code...}
	catch(ArithmeticException e){//specific handling code...}
	catch(RuntimeException e){//specific handling code...}
	catch(Exception e){//generic handling code...}
	
finally:
--------

throws:
-------

throw:
------

=====================================================================
Inappropriate order of the catch blocks:

try{
	//citical statements
}
catch(Exception e1){...; e1.someMethod();....;}
catch(RuntimeException e2){...; e2.someMethod();....;}
catchArrayIndexOutOfBoundsException e3){...; e3.someMethod();....;}
catch(ArithmeticException e4){...; e4.someMethod();....;}
catch(IOException e5){...; e5.someMethod();....;}
catch(EOFException e6){...; e6.someMethod();....;}

------------------------------------------------------
Right order of the catch blocka:

try{
	//citical statements
}
catch(ArrayIndexOutOfBoundsException e3){...; e3.someMethod();....;}
catch(ArithmeticException e4){...; e4.someMethod();....;}
catch(RuntimeException e2){...; e2.someMethod();....;}
catch(EOFException e6){...; e6.someMethod();....;}
catch(IOException e5){...; e5.someMethod();....;}
catch(Exception e1){...; e1.someMethod();....;}



==================================================================================