2021-11-08 -- Scratchpad of CSE213 (Sec-4)
==========================================

Today's Agenda:
--------------
a) Introduction to Inheritance
b) Understanding 'Object' class
c) Method Overriding
d) Understanding relationships among different classes
e) Introduction to Polymorphism

Introduction to Inheritance:
============================
 - Inheritance allows us to extend a pre-existing class to get a new class.

	public class Person{
		private fields: name, id, dob, address, salary, contactNo,
			email, bg, height, weight,...
		//not ALL instances qualifies for these fields
	}

	public class Person{
		private fields: name, dob, bg, height, weight,...
		//every instance qualifies for these fields
	}

 - Class which is being extended is called: super/base/parent class

 - Newly extended class is called: sub/derived/child class

 - Subclass is a more specific-type of superclass, because it establish "is-a"
	relationship with the superclass

 - Subclass inherits ALL fields and methods from superclass, and on top of that 
	it can have its own additional fields and methods

- If the superclass author declares the fields as private, then the subclass
	need to use non-private getter/setter of superclass to use those inherited fields.
	Also, subclass parameterized constructor needs to indicate to compiler
	to fire superclass parameterized constructor, where some of the 
	parameters received by subclass-constructor will be specified as 
	parameters of superclass-constructor

- If superclass author anticipates that this class may need to be extended in 
	future, then the fields should be declared as protected (instead of 
	private) to make it convenient for subclass author

- superclass handle can be used to represent non only superclass instances,
	BUT ALSO ANY SUBCLASS instances

	public class Weapon{...}		//superclass
	public class Granade extends Weapon{.....}//subclass, "is-a" satisfied
	public class Pistol extends Weapon{.....}//subclass, "is-a" satisfied
	public class Sword extends Weapon{.....}//subclass, "is-a" satisfied

	Weapon w1,w2,w3,w4;
	w1 = new Weapon();
	w2 = new Granade();
	w3 = new Pistol();

 
------------------------------------------------------------------------------------------


Parameterized constructor in subclass (inheritance)
---------------------------------------------------
public Student(int id, float f, String str1, String str2, String str3) {
	this.id = id;
	cgpa = f;
	name = str1;
	dob = str2;
	gender = str3;
}


//see netbeans project for full code
public Student(int id, float cgpa, String name, String dob, String gender) {
	this.id = id;
	this.cgpa = cgpa;
	this.name = name;
	this.dob = dob;
	this.gender = gender;
}

==============================================================================================
2021-11-08 -- Scratchpad of CSE213 (Sec-4)
==========================================

Understanding 'Object' class:
-----------------------------
public class A{...}
Q: Who is the superclass of A?
A: class 'Object'


public class B extends A{...}	
Q: Who is the superclass of B?
A: class 'A'

	- Object is a special class in Java.
	- Object class is the ADAM of java species. It means, every java class is directly
	   or indirectly inherits all fields & methods of 'Object' class
	- You will understand more on some of these inherited methods of 'Object' class
	   after doing OS course


==============================================================================================

Method overriding:
==================
- If a subclass author is not happy with the definition of an inherited method of the
	superclass, then the subclass author can redefine the method as its own
	method. In that case, there will method-overloading violation (because
	both inherited and own version will have SAME parameter list). Therefore
	the compiler should deactivate/nullify inherited definition so that there
	will be no method-overloading voilation.
	This is called method OVERRIDING.

Case-1: Superclass method/s is/are not overridden
-------------------------------------------------
  public class Vehicle{
	protected fields: brand, model, cc, price
	public void show(){
		//print the fields of Vehicle class
	}
  }


  public class Car extends Vehicle{
	additional private fields: regNo, noOfSeat,..
	//show method is inherited from Vehicle class
  }

  public class MainClass{
    p s v main(...){
	Car myCar = new Car();
	myCar.setInfo();
	myCar.show();	//Problem: NOt ALL fields are printed, if not Overridden
    }
  }


Case-2: Superclass method/s is/are overridden in subclass
---------------------------------------------------------
  public class Vehicle{
	protected fields: brand, model, cc, price
	public void show(){
		//print the fields
	}
  }
  public class Car extends Vehicle{
	additional private fields: regNo, noOfSeat,..
	//inherited show method is deactivated
	//@Override
	public void show(){
		//code to print ALL fields (inherited + additional)
	}
  }
  public class MainClass{
    p s v main(...){
	Car myCar = new Car();
	myCar.setInfo();
	myCar.show();	//Solved:  ALL fields are printed, Overridden
    }
  }

Difference between method overloading and method overriding:
------------------------------------------------------------

 - In overloading, All versions of the method is available for execution for SAME client, 
   but in overriding inherited version can never be called for subclass client

- For overloading, ALL versions must have unique parameter list, but in overriding both
  inherited and own version has same parameter list (hence to avoid ambiguity, deactivate
  inherited one)

- Overloaded versions may be written in same class, OR 
  some of them can be written in superclass and some of them can be written in subclass.
  BUT, overridden versions will be written: one in superclass, and another in subclass

========================================================================================

Relationships among classes:
----------------------------

a) Inheritance
	- Extension of pre-existing superclass
	- Establishes "is-a" relationship

b) Aggregation
	- A class contains a handle of another pre-existing class, as its field
	- Establishes "has-a" relationship

	- Aggregation implies a relationship where the aggregated (which is a Preexisting class's
	   handle as a field of new class being defined) class instance can exist independently 
	   of the aggregating (the new class) class instance.

	Name of pre-existing class				: String
	Name of new class					: Student
	Name of field (handle name of pre-existing class)	: class Student{ 
									private String name;
								  }

	    	Example-1: 
		----------
		 - Toilet is a preexisting class
			public class Toilet {....}

		 - Auditorium is the new class being defined	
			public class Auditorium{
				private Toilet[] toiletArr;
			}

		- Here Auditorium is aggregating class, and Toilet is aggregated class,
		  and Toilet instances exists outside/independent of Auditorium in IUB

	    	Example-2: Totota Corporation
		-----------------------------
		 - Engine is a preexisting class
			public class Engine {....}	

		 - Car is the new class being defined
			public class Car{
				private Engine eng;
			}

		- Here Car is aggregating class, and Engine is aggregated class,
		  and Engine instances exists outside of Car instance as SPARE parts in Toyota


c) Composition
	- A class contains a handle of another pre-existing class, as its field
	- Establishes "has-a" relationship
	- Composition implies a relationship where the composed (which is a Preexisting class's
	   handle as a field of new class being defined) class instance can NOT exist 
	   independently of the composing (the new class) class instance.

	    	Example-1: 
		----------
		 - Engine is a pre-existing class
			public class Engine {....}	
			public class TurboEngine extends Engine {....}	

		 - Car is the new class being defined
			public class Car{
				private Engine eng;
			}
			public class SportsCar extends Car{
				
			}

		- Here Car is composing class, and Engine is composed class,
		  and Engine instances Cannot exists outside of Car instance in IUB system

d) Association
	- When One class's method interact with another class's method (using one another),
	  but there is no "is-a" / "has-a" relationship, then we call it association

Mini classroom Exercise:
------------------------
From your own project topic, give example for:

Project Topic: Feed Producing Company

- Inheritance ("is-a")	: 
	superclass name	: User
	subclass name	: Supplier
 
- Aggregarion ("has-a")	:
	Name of pre-existing class				: class Date{...}
	Name of new class					: FactoryManager
	Name of field (handle name of pre-existing class)	: class Bbbb{ 
									private Date dob, doj;
								  }
- Composition ("has-a")	:
	Name of pre-existing class				: Aaaa
	Name of new class					: Bbbb
	Name of field (handle name of pre-existing class)	: class Bbbb{ 
									private Aaaa obj;
								  }
- Association: 
	user-classname	: Faculty		/	FactoryManager	/ Client
	used-classname 	: Student		/	Supplier	/ Band
	use/task	: assigns (assignment)	/	sends(order)    / books

========================================================================================

Polimorphism:
-------------
	- Poly: many
	- Morphing: Smooth transition of image to different form

	- Polymorphism in Java is the ability of an object to take many forms. 
	  To simply put, polymorphism in java allows us to perform the same action in many
	  different ways. It is a feature of the object-oriented programming, which allows a
	  single task to be performed in different ways (depending on runtime context).

	- Inheritance is involved in acheiving polymorphism (as superclass handle can be used
	  to represent any subclass instances of the inheritance hierarchy)

	Example:
	--------
		Video Game: pubji, Valorent

		- Assume, a warfare game has different types of weapons as resources for the player
	 		public class Granade{...}
	 		public class Pistol{...}
	 		public class Sword{...}

		- To preserve the collected weapons, there need to be 3 DIFFERNT ARRAYs 
		  (more dynamic collection alternate of Array) for Granade, Pistol & Sword
			Granade[] granadeArr;
			Pistol[] pistolArr;
			Sword[] swordArr;	

			granadeArr[i] = new Granade();
			PistolArr[i] = new Pistol();
			swordArr[i] = new Sword();

		- But if we want to maintain only ONE ARRAY instead of three, then we can
		  introduce a superclass called Weapon, and make Granade, Pistol & Sword
		  as subclasses, and then we can use a SINGLE array of Weapon
			public class Weapon{
				public void overhaul(){...}
			}
	 		public class Granade extends Weapon{
				...
				@Override
				public void overhaul(){ //code specific to overhaul a granade }
			}
	 		public class Pistol extends Weapon{
				...
				@Override
				    public void overhaul(){ //code specific to overhaul a pistol }				}
	 		public class Sword extends Weapon{
				...
				@Override
				public void overhaul(){ //code specific to overhaul a sword }		
			}
			Weapon[] weaponArr;			
			weaponArr[i] = new Granade();
			weaponArr[j] = new Pistol();
			weaponArr[k] = new Sword();
			
			for(....){ weaponArr[i].overhaul(); }


		- In Game player's perspective, its not possible to anticipate how many 
		  resources the player can collect at runtime. Therefore, using array is not a
		  good option. Hence we can use one of the dynamic collection classes from 
		  library which can grow on demand in phases. Most of these collection classes
		  are "generic" too.

		- Let's decide that we are going to use ArrayList collection (also generic )class 
		  to collect different types of weapons for the player and demonstrate polymorphic
		  behaviour of a method (common-method or uncommon-method??? We are going 
		  to discover that)

	----------------------------------------------------------------
	public class MyStack{	//fixed-sized stack of 10
		int top;
		int[] values; //int *valPtr;
		public MyStack(int n){ top=-1; values = null; }
		public MyStack(int n){ top=-1; values = new int[n]; }
		//methods
	}

	p s v main(...){
		MyStack stk1 = new MyStack(10); 
		// we can store (push) only integer to this stk1. This is not a generic class
	}

	Generic class:
	-------------
	public class MyGenericStack<E>{	//fixed-sized stack of 10
		int top;
		E[] values; //E *valPtr;
		public MyStack(int n){ top=-1; values = null; }
		public MyStack(int n){ top=-1; values = new E[n]; }
		//methods
	}

	public class Book{...}
	p s v main(...){
		MyGenericStack<int> stkOfInts = new MyStack<int>(10); 
		MyGenericStack<int> stkOfBooks = new MyStack<Book>(10); 
		MyGenericStack<String> stkOfNames = new MyStack<String>(10); 
		// we can store (push) any type of premitives/handles to this generic class instance
	}


Next class to cover (7-NOV-21):
-------------------------------
	- Complete sample workflow for a IRAS goal
	- Discussion on different UML diagrams which are typically used for system design. 
	  BUT due to time limitation, we will limit ourselves to "UML class-diagram" only.
	  You will know more UML diagrams related to system design in 
	  "System Analysis and Design" core course in future

	- Introduction to online tool "lucidchart" to create out class diagram

	- How to use milestone-1 (CRA-report) to construct milestone-2 deliverables:
		- class diagram
		- database design (file system)
 





----------------
float f = 3.59368475983475093475304753408957398573;	//ok in c++, double will be stored in float
float f = 3.5;	//Error in java, double will not be stored as float by default
float f = 3.5f;	//Error in java, double will not be stored as float by default


public class Test{

	int x;
	public Test(int val){ x = val; }
	public Test(int x){ this.x = x; }




