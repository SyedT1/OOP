2021-11-15 -- Scratchpad of CSE213 (Sec-2)
==========================================

	- Multiple Inheritance and Interface
	- 'final' keyword
	- Wrapper class
	- Understanding MVC framework
	- Introduction to FXML application development
	- Writing workflow for a sample goal (IRAS) and how to proceed for milestone-2

========================================================================================

Simple inheritance:
-------------------
SuperClass	:	Food
SubClass	:	WholeFood / ProcessedFood

MultiLevel inheritance:
-----------------------
SuperClass	:	Employee
SubClass	:	Faculty
SubSubClass	:	AdjunctFaculty

Multiple Inheritance:
---------------------
	- If a subclass has two or more (multiple) ancestors, then we call it multiple-inheritance

	public class Super1{
		//protected fields
		public void doSome1(){...}
		//public void print(){....}
	}

	public class Super2{
		//protected fields
		public void doSome2(){...}
		//public void print(){....}
	}


	public class Sub extends Super1, Super2{ 	//say for the sake of discussion
		//additional private fields
		public void doSomeOwnWork(){...}
	}
	
	p s v m(....){
		Sub obj = new Sub();
		obj.doSome1();		//OK
		obj.doSome2();		//OK
		obj.doSomeOwnWork();	//OK
		//obj.print();		//Ambiguity, NOT OK
		//Two definitions of same signature is inherited from two ancsetors
		//creating ambiguity/confusion to compiler, not acceptable

		//C++ will leave the responsibility to discover such ambiguity of multiple
		//definition conflict of same method inherited from different superclasses on the
		//programmer. It will allow the subclass to have multiple superclasses to acheive
		//multiple inheritance

		//On the other hand, Java knows that there is a potential of having such definition
		//conflict in subclass, therefore java does not ALLOW a subclass to have more than
		//one superclass. 
		Q: Then How multiple inheritance can be acheived in Java?
		A: 
			- Java subclass can have one superclass as an ancestor
			- And the subclass can have rest of the ancestors as "Interface"

Interface:
----------
	- It is a cousin of Abstract class
	- An interface can't have any implemented (non-abstract methods) method. 
	  ALL methods in an intercace MUST be ABSTRACT method
	- Fields of an interface must be: static as well as final (shared as well as constant)	

	Syntax:
	public class NewClassName extends SuperClassName implements InterfaceName1, InterfaceName2{
		//...
	}

	
Q: If no methods are implemented in an Interface, that what is its role?
A: 
	- Interface's role is to enforce certain behaviour in implementing class
	- It focuses on 'what' behaviour, not on 'how' the behaviour is exhibited
	NOTE:
	- Superclass also enforce behaviour on subclass.
	    - abstract method of superclass focuses on 'what' behaviour should be exhibited
		in subclass
	    - Non-abstract (implemented) method of superclass focuses on 'what & how' a behaviour 
		should be exhibited in subclass

Q: Then, why can't we keep those abstract methods of interface in the superclass itself
	instead of creating those interfaces, and avoid multiple inheritance alltogether?
A:
	- If a method of superclass is not relevant to ALL subclasses (including sub-subclasses),
	   but relavent to some of them only, then we can't keep that method in superclass.
	- Therefore, we will keep that abstract-method in an interface and all relevant can implements
	   that interface to have that behaviour.
	- Also, if we want to instantiate the super class too, then we can't keep those abstract 
	   methods in the superclass and make the class abstract.





========================================================================================

'final' keyword:
-----------------
	- final field: constant, once value is given, it can't be changed. value MUST be
	  given at the time of memory allocation

		C++: 	int x;
			x=20;
			const int y;	//error
			const int y=20;	//OK, y will be 20 for its lifetime


		Java: 	int x;
			x=20;
			final int y;	//error
			final int y=20;	//OK, y will be 20 for its lifetime

		Example:
		Access-Specifier		<className, fieldName>
		------------------------------------------------------
		non-static & non-final:		<Student , cgpa>

		non-static & but final:		<Student , id/dateOfJoining>
						<implicitArrayClass , length>

		static & but non-final:		<Student , hotlineNo>

		static & final:			<UniInfo/Student , uniName>


	- final method: its a superclass method (implemented), which can't be overridden 
		in subclass


	- final class: its a class which can't be extended


====================================================================================
Wrapper class:
==============
	- Many library classes has methods which has generic parameter where the generic type(say E)
	  needs to be replaced with a real type.
	- Often times this generic types MUST be replaced with a valid class
	- In that case, if we want to replace the generic type with a primitive (int, float, etc),
	  we can't do that. Instead, we have to replave the generic type 'E' with corrosponding class
	  equivalent of the primitive, a.k.a Wrapper class.

		primitive		Wrapper class name
		------------------------------------------
		int			Integer
		float			Float
		and so on...

	- These wrapper classes not only allows the primitives to be used to replace a generic type,
	  they are also loaded with many useful methods associated with that primitive type.
	  Some of these methods are typically static, so that they can be called without any
	  wrapper class instance as client (wrapper class name can be used as the client)

	- Example:
		ArrayList<Weapon> wList = new AyyarList<Weapon>();	//OK
		ArrayList<int> intList = new AyyarList<int>();		//error
		ArrayList<Integer> intList = new AyyarList<Integer>();	//OK
		intList.add(12); int x=20; intLIst.add(x);		//OK

		String str="123";
		int x = str;		/error
		x = Integer.parseInt(str);
		int x=1234;
		String str = Integer.toString(x);
================================================================================================


MVC Framework:
==============
	- Model		: Collection of classes representing your application data.
			  Ex: Product, Employee, Supplier, Order, Customer, Ticket

	- View		: Graphical User Interface ( collection of pages(web-application) 
			  / scenes (mobile/desktop application) )
			  - Web pages are typically represnted by (.html/.php/.asp, etc)
			  - Scenes of your project will be represented by (.fxml) java fxml files
			  - Java FXML is based on XML which allows to creaed own tags

	- Controller	: Collection of controller classes corresponds to the scenes
			  - Typically if there are 50 scenes in your project, then ideally there 
				will be 50 controller classes

			  - A controller class is a collection of event-handling methods generated
				by user at runtime. 
			  - It also contains the class instances of the elements that we see on that
				scene. For example, if we see a button and a text area to type user
				input in a scene, then there will be a 'Button' and 'TextArea' class
				instances as the private fields of that controller class (aggregation)


=============================================================================================

Milestone-2: System Design:
---------------------------
 - It includes many things, but we will restrict ourselves in producing following deliverables:
	- UML class diagram
	- File structure (representing database)
 - To produce the above, we need a compresensive CRA-report in place (Milestone-1)

------------------------------------------------------------------------------------------------

Steps to built class diagram:
-----------------------------

 - Understand the growth volume of the class-instances and normalize the high-volume growth classes
	- (We will try to understand this by our own terms "Master" and "Transaction" classes)
	- Avoid redundant fields to restrict volume

 - Analyzing CRA report:
    - Identify Model classes/interfaces representing application data:
      ----------------------------------------------------------------
  	- Identify USER classes
  	- Identify NON-USER classes
  	- Identify interfaces

	- Finalize decision about the user defined type
		- Decide whether the type will be a:
			 abstract-class / non-abstract class / interface

	- Finalize decision about the fields
		- Decide whether the field is static or non-static
		- Decide whether the field is final or not

	- Finalize decision about the methods
		- Decide whether the method is static or non-static
		- Decide whether the method is abstract or not
		- Decide whether the method is final or not
		- ## Does this method returns data back to the UI-scene or not?
			: this will guide to decide the return type of the method

    - Identify Controller classes representing UI-scene:
      --------------------------------------------------
	 - We will talk more on this when we start building FXML application (next class)
=================================================================================================

Master vs Transaction class:
============================

Master class: 
-------------
	- Class which has a unique field (value of the field is unique for each instances) 
	  to identify an instance. 
	- Also the growth of instance volume (database size) is under control / insignificant

Transaction class: 
------------------
	- Class which has NO unique field (value of the field is unique for each instances) 
	  to identify an instance. 
	- Also the growth of instance volume (database size) is quite high

Example: Dutch Bangla Bank Limited:
-----------------------------------

#: No of daily new Account (class) os opened for the bank:
	- No of branch: 214
	- No of Fast Track booth: 1268
	- No of ATM: 4930
	- No of Agent banking: 63
	- Assume, no of new accounts opened in a branch: 100
	- Assume, no of new accounts opened in DBBL Fast Track booth: 50
	- Assume, no of new accounts opened through DBBL Agent banking: 30

 - No of new accounts: 214*100 + 1268*50 + 63*30 = 67,430
 - In DBBL data center, 67,430 new records (Account class instances) are added to the database


#: No of daily bank-transactions occured in DBBL:
	- No of cash deposit in a branch: 500 				* 214 	= 107000
	- No of check deposit in a branch: 700 				* 214 	= 149800
	- Deposit cash using CDM in fast track: 100 			* 1268 	= 126800
	- Deposit check using CDM in fast track: 200			* 1268 	= 263600
	- Online fund transfer via internet banking: 50000		       	= 50000
	- Online fund transfer via rocket (mobile banking): 10000	       	= 10000

	- Withdrwal cash from each ATM: 300				* 4930 	= 1479000
	- Encashing check from each branch: 700				* 214  	= 149800
	- Wihdrwal as a result of online fund transfer:			       	= 50000
	---------------------------------------------------------------------------------
	Total bank-transactions of DBBL per day:				= 2341000

- Growth of volume: 67,430 vs 2341,000


public class Account{
	fields: accountNo, accountName, typeOfAccount, balance,
	address, email, contactNo, NID, .....
}
	- has unique field
	- volume growth under control
	- It is a Master class

public class BankTransaction{
	fields: locationId, amount, typeOfTransaction, date, processedBy, 
	accountNo, accountName, contactNo
}
	- No unique field
	- volume growth is quite high
	- It is a Transaction class

- Since volume growth is quite high, we need to normalize the class by eliminating 
  redundant fields
- Also we can add an unique identifyer (new unique field) to the class as follows

public class BankTransaction{
	fields: transactionId,
	accountNo, locationId, amount, typeOfTransaction, date, processedBy
}

=================================================================================================

- After detection of classes, we need to establish relationships among those classes:
	- inheritance
	- aggregation
	- composition
	- association and multiplicity (1:1, 1:M, M:1, M:M, *:1, *:M, M:*)

- Then draw the UML class diagram for the above using one of the online tools. We will
  use lucidchart

=================================================================================================

Writing workflow for a sample goal (IRAS):
==========================================

User: Student
  - Goal-1: Register courses for upcoming semester
    - Workflow:
	e1: check login credential (give detail....)
	e2: if login successful, load Student-specific homeScene, else go-back to login/forgotPW
	e3: after selecting "rigister course" option, it will check the following: document pending/
		date & time-slot/ probation-status. If verified positive, a new scene will appear and
		pre-loaded with ALL applicable offered-course (including prerequisites...) for the 
		student. Else, it will prompt to contact the registrar office.
	e4: Student will select ONE-Course at a time and it will check:
		- capacity, time-clash-with-already-selected-courses
	e5: proceed to register, and it will check:
		- final Check of capacity for all selected courses
		- no of credit taken is within the range [9 to 18]
		- for "Course/Lab" paired courses whether one is left out or not
		- ....
	e6: If above checking are positive, comit to database and generate bill.
	    	Bill content: .......


Drawing UML class-diagram (partial) using CRA-Report (IRAS):
============================================================

public class Student:

public class Faculty:
	- facultyId, facultyName, desig, dept, salary, doj, dob,....

public class Course: [Master class]
	- courseId, courseTitle, noOfCredits, preRequisiteList,...

public class CourseTimeStamp{
	year, semester, day, time;
}


public class OfferedCourse: [Transaction class]
	- courseId, courseTitle, noOfCredits, sec, CourseTimeStamp timeStamp, facultyId, facultyName,
		location


public class OfferedCourse: [Normalizing Transaction class, eliminating redundant fields]
	- courseId, sec, CourseTimeStamp timeStamp, facultyId, location

public class RegistrationBill:
	- billNo, totalAmount
	- public void generateBillPdf(){
		use "1234567-registeredcourse.bin" file rom database
	}


----------------------
RegisterCourseScene.fxml
class RegisterCourseSceneController .....{
	@FXML private
	ArrayList<CourseTimeStamp> selectedCourseTimeStamp;
	ArrayList<Integer> selectedCourseIDs;
	proceedToRegisterCourseButtonOnClick(...){
		//commit to database
		write to file: "1234567-registeredcourse.bin"
		int <student id>
		int<1th-coutseId>, selectedCourseTimeStamp-instance
		int<2th-coutseId>, selectedCourseTimeStamp-instance
		int<3th-coutseId>, selectedCourseTimeStamp-instance
		int<4th-coutseId>, selectedCourseTimeStamp-instance
		.....
		int<nth-coutseId>, selectedCourseTimeStamp-instance
		//arraylist end here
		//end of file writing
	}

}













	







































